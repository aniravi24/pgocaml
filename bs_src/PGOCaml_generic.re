/* PG'OCaml is a set of OCaml bindings for the PostgreSQL database.
 *
 * PG'OCaml - type safe interface to PostgreSQL.
 * Copyright (C) 2005-2009 Richard Jones and other authors.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this library; see the file COPYING.  If not, write to
 * the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 * Boston, MA 02111-1307, USA.
 */

open PGOCaml_aux;
open Printf;

module type Js = {
  type t('a);
  module type Date = {
    type t('a);
  }
}

module type THREAD = {
  type t('a);
  let return: 'a => t('a);
  let (>>=): (t('a), 'a => t('b)) => t('b);
  let fail: exn => t('a);
  let catch: (unit => t('a), exn => t('a)) => t('a);

  type in_channel;
  type out_channel;
  let open_connection: Unix.sockaddr => t((in_channel, out_channel));
  let output_char: (out_channel, char) => t(unit);
  let output_binary_int: (out_channel, int) => t(unit);
  let output_string: (out_channel, string) => t(unit);
  let flush: out_channel => t(unit);
  let input_char: in_channel => t(char);
  let input_binary_int: in_channel => t(int);
  let really_input: (in_channel, Bytes.t, int, int) => t(unit);
  let close_in: in_channel => t(unit);
};

module type PGOCAML_GENERIC = {
  /** Database handle. */

  type t('a);

  type monad('a);

  type isolation = [
    | `Serializable
    | `Repeatable_read
    | `Read_committed
    | `Read_uncommitted
  ];

  type access = [ | `Read_write | `Read_only];

  /** For library errors. */

  exception Error(string);

  /** For errors generated by the PostgreSQL database back-end.  The
  * first argument is a printable error message.  The second argument
  * is the complete set of error fields returned from the back-end.
  * See [http://www.postgresql.org/docs/8.1/static/protocol-error-fields.html]
  */

  exception PostgreSQL_Error(string, list((char, string)));

  /** {6 Connection management} */;

  type connection_desc = {
    user: string,
    port: int,
    password: string,
    host: [ | `Hostname(string) | `Unix_domain_socket_dir(string)],
    database: string,
  };

  /** Produce the actual, concrete connection parameters based on the values and
  * availability of the various configuration variables.
  */

  let describe_connection:
    (
      ~host: string=?,
      ~port: int=?,
      ~user: string=?,
      ~password: string=?,
      ~database: string=?,
      ~unix_domain_socket_dir: string=?,
      unit
    ) =>
    connection_desc;

  /** Produce a human-readable textual representation of a concrete connection
  * descriptor (the password is NOT included in the output of this function)
  * for logging and error reporting purposes.
  */

  let connection_desc_to_string: connection_desc => string;

  /** Connect to the database.  The normal [$PGDATABASE], etc. environment
  * variables are available.
  */

  let connect:
    (
      ~host: string=?,
      ~port: int=?,
      ~user: string=?,
      ~password: string=?,
      ~database: string=?,
      ~unix_domain_socket_dir: string=?,
      ~desc: connection_desc=?,
      unit
    ) =>
    monad(t('a));

  /** Close the database handle.  You must call this after you have
  * finished with the handle, or else you will get leaked file
  * descriptors.
  */

  let close: t('a) => monad(unit);

  /** Ping the database.  If the database is not available, some sort of
  * exception will be thrown.
  */

  let ping: t('a) => monad(unit);

  /** This function is a wrapper of [ping] that returns a boolean instead of
  * raising an exception.
  */

  let alive: t('a) => monad(bool);

  /** {6 Transactions} */;

  /** Start a transaction. */

  let begin_work:
    (
      ~isolation: isolation=?,
      ~access: access=?,
      ~deferrable: bool=?,
      t('a)
    ) =>
    monad(unit);

  /** Perform a COMMIT operation on the database. */

  let commit: t('a) => monad(unit);

  /** Perform a ROLLBACK operation on the database. */

  let rollback: t('a) => monad(unit);

  /** [transact db ?isolation ?access ?deferrable f] wraps your
  * function [f] inside a transactional block.
  * First it calls [begin_work] with [isolation], [access] and [deferrable],
  * then calls [f] and do [rollback] if [f] raises
  * an exception, [commit] otherwise.
  */

  let transact:
    (
      t('a),
      ~isolation: isolation=?,
      ~access: access=?,
      ~deferrable: bool=?,
      t('a) => monad('b)
    ) =>
    monad('b);

  /** {6 Serial column} */;

  /** This is a shorthand for [SELECT CURRVAL(serial)].  For a table
  * called [table] with serial column [id] you would typically
  * call this as [serial dbh "table_id_seq"] after the previous INSERT
  * operation to get the serial number of the inserted row.
  */

  let serial: (t('a), string) => monad(int64);

  /** As {!serial} but assumes that the column is a SERIAL or
  * SERIAL4 type.
  */

  let serial4: (t('a), string) => monad(int32);

  /** Same as {!serial}.
  */

  let serial8: (t('a), string) => monad(int64);

  /** {6 Miscellaneous} */;

  /** Maximum message length accepted from the back-end.  The default
  * is [Sys.max_string_length], which means that we will try to read as
  * much data from the back-end as we can, and this may cause us to
  * run out of memory (particularly on 64 bit machines), causing a
  * possible denial of service.  You may want to set this to a smaller
  * size to avoid this happening.
  */

  let max_message_length: ref(int);

  /** Verbosity.  0 means don't print anything.  1 means print short
  * error messages as returned from the back-end.  2 means print all
  * messages as returned from the back-end.  Messages are printed on [stderr].
  * Default verbosity level is 1.
  */

  let verbose: ref(int);

  /** Attach some private data to the database handle.
  *
  * NB. The pa_pgsql camlp4 extension uses this for its own purposes, which
  * means that in most programs you will not be able to attach private data
  * to the database handle.
  */

  let set_private_data: (t('a), 'a) => unit;

  /** Retrieve some private data previously attached to the database handle.
  * If no data has been attached, raises [Not_found].
  *
  * NB. The pa_pgsql camlp4 extension uses this for its own purposes, which
  * means that in most programs you will not be able to attach private data
  * to the database handle.
  */

  let private_data: t('a) => 'a;

  let uuid: t('a) => string;

  /** When using pa_pgsql, database handles have type
  * [PGOCaml.pa_pg_data PGOCaml.t]
  */

  type pa_pg_data = Hashtbl.t(string, bool);

  /** {6 Low level query interface - DO NOT USE DIRECTLY} */;

  [@deriving show]
  type oid = int32;

  type param = option(string); /* None is NULL. */
  type result = option(string); /* None is NULL. */
  type row = list(result); /* One row is a list of fields. */

  /** [prepare conn ~query ?name ?types ()] prepares the statement [query]
  * and optionally names it [name] and sets the parameter types to [types].
  * If no name is given, then the "unnamed" statement is overwritten.  If
  * no types are given, then the PostgreSQL engine infers types.
  * Synchronously checks for errors.
  */

  let prepare:
    (t('a), ~query: string, ~name: string=?, ~types: list(oid)=?, unit) =>
    monad(unit);

  let execute_rev:
    (
      t('a),
      ~name: string=?,
      ~portal: string=?,
      ~params: list(param),
      unit
    ) =>
    monad(list(row));
  /** [execute conn ?name ~params ()] executes the named or unnamed
  * statement [name], with the given parameters [params],
  * returning the result rows (if any).
  *
  * There are several steps involved at the protocol layer:
  * (1) a "portal" is created from the statement, binding the
  * parameters in the statement (Bind).
  * (2) the portal is executed (Execute).
  * (3) we synchronise the connection (Sync).
  *
  * The optional [?portal] parameter may be used to name the portal
  * created in step (1) above (otherwise the unnamed portal is used).
  * This is only important if you want to call {!PGOCaml.describe_portal}
  * to find out the result types.
  */

  let execute:
    (
      t('a),
      ~name: string=?,
      ~portal: string=?,
      ~params: list(param),
      unit
    ) =>
    monad(list(row));

  let cursor:
    (
      t('a),
      ~name: string=?,
      ~portal: string=?,
      ~params: list(param),
      row => monad(unit)
    ) =>
    monad(unit);

  /** [close_statement conn ?name ()] closes a prepared statement and frees
  * up any resources.
  */

  let close_statement: (t('a), ~name: string=?, unit) => monad(unit);

  /** [close_portal conn ?portal ()] closes a portal and frees up any resources.
  */

  let close_portal: (t('a), ~portal: string=?, unit) => monad(unit);

  /** [inject conn ?name query] executes the statement [query]
  * and optionally names it [name] and gives the result.
  */

  let inject: (t('a), ~name: string=?, string) => monad(list(row));

  /** [alter conn ?name query] executes the statement [query]
  * and optionally names it [name]. Same as inject but ignoring the result.
  */

  let alter: (t('a), ~name: string=?, string) => monad(unit);

  [@deriving show]
  type result_description = {
    /** Field name. */
    name: string,
    /** OID of table. */
    table: option(oid),
    /** Column number of field in table. */
    column: option(int),
    /** The type of the field. */
    field_type: oid,
    /** Length of the field. */
    length: int,
    /** Type modifier. */
    modifier: int32,
  };
  [@deriving show]
  type row_description = list(result_description);

  type param_description = {
    /** The type of the parameter. */
    param_type: oid,
  };
  type params_description = list(param_description);

  /** [describe_statement conn ?name ()] describes the named or unnamed
  * statement's parameter types and result types.
  */

  let describe_statement:
    (t('a), ~name: string=?, unit) =>
    monad((params_description, option(row_description)));

  /** [describe_portal conn ?portal ()] describes the named or unnamed
  * portal's result types.
  */

  let describe_portal:
    (t('a), ~portal: string=?, unit) => monad(option(row_description));

  /** {6 Low level type conversion functions - DO NOT USE DIRECTLY} */;

  /** Returns the OCaml equivalent type name to the PostgreSQL type [oid].
  * For instance, [name_of_type (Int32.of_int 23)] returns ["int32"] because
  * the OID for PostgreSQL's internal [int4] type is [23].  As another
  * example, [name_of_type (Int32.of_int 25)] returns ["string"].
  */

  let name_of_type: oid => string;

  type inet = (Unix.inet_addr, int);
  type timestamptz = (Js.Date.t, Js.Date.t);
  type int16 = int;
  type bytea = string; /* XXX */
  type point = (float, float);
  type hstore = list((string, option(string)));
  type numeric = string;
  type uuid = string;
  type jsonb = string;

  type bool_array = list(option(bool));
  type int32_array = list(option(int32));
  type int64_array = list(option(int64));
  type string_array = list(option(string));
  type float_array = list(option(float));
  type timestamp_array = list(option(Js.Date.t));

  /** The following conversion functions are used by pa_pgsql to convert
  * values in and out of the database.
  */;

  let string_of_oid: oid => string;
  let string_of_bool: bool => string;
  let string_of_int: int => string;
  let string_of_int16: int16 => string;
  let string_of_int32: int32 => string;
  let string_of_int64: int64 => string;
  let string_of_float: float => string;
  let string_of_point: point => string;
  let string_of_hstore: hstore => string;
  let string_of_numeric: numeric => string;
  let string_of_uuid: uuid => string;
  let string_of_jsonb: jsonb => string;
  let string_of_inet: inet => string;
  let string_of_timestamp: Js.Date.t => string;
  let string_of_timestamptz: timestamptz => string;
  let string_of_date: Js.Date.t => string;
  let string_of_time: Js.Date.t => string;
  let string_of_interval: Js.Date.t => string;
  let string_of_bytea: bytea => string;
  let string_of_string: string => string;
  let string_of_unit: unit => string;

  let string_of_bool_array: bool_array => string;
  let string_of_int32_array: int32_array => string;
  let string_of_int64_array: int64_array => string;
  let string_of_string_array: string_array => string;
  let string_of_bytea_array: string_array => string;
  let string_of_float_array: float_array => string;
  let string_of_timestamp_array: timestamp_array => string;
  let string_of_arbitrary_array: ('a => string, list(option('a))) => string;

  let comment_src_loc: unit => bool;

  let find_custom_typconvs:
    (
      ~typnam: string=?,
      ~lookin: string=?,
      ~colnam: string=?,
      ~argnam: string=?,
      unit
    ) =>
    Belt.Result.t(option((string, string)), string);

  let oid_of_string: string => oid;
  let bool_of_string: string => bool;
  let int_of_string: string => int;
  let int16_of_string: string => int16;
  let int32_of_string: string => int32;
  let int64_of_string: string => int64;
  let float_of_string: string => float;
  let point_of_string: string => point;
  let hstore_of_string: string => hstore;
  let numeric_of_string: string => numeric;
  let uuid_of_string: string => uuid;
  let jsonb_of_string: string => jsonb;
  let inet_of_string: string => inet;
  let timestamp_of_string: string => Js.Date.t;
  let timestamptz_of_string: string => timestamptz;
  let date_of_string: string => Js.Date.t;
  let time_of_string: string => Js.Date.t;
  let interval_of_string: string => Js.Date.t;
  let bytea_of_string: string => bytea;
  let unit_of_string: string => unit;

  let bool_array_of_string: string => bool_array;
  let int32_array_of_string: string => int32_array;
  let int64_array_of_string: string => int64_array;
  let string_array_of_string: string => string_array;
  let float_array_of_string: string => float_array;
  let timestamp_array_of_string: string => timestamp_array;
  let arbitrary_array_of_string: (string => 'a, string) => list(option('a));

  let bind: (monad('a), 'a => monad('b)) => monad('b);
  let return: 'a => monad('a);
};

module Make = (Thread: THREAD) => {
  open Thread;

  type connection_desc = {
    user: string,
    port: int,
    password: string,
    host: [ | `Hostname(string) | `Unix_domain_socket_dir(string)],
    database: string,
  };

  type t('a) = {
    ichan: in_channel, /* In_channel wrapping socket. */
    chan: out_channel, /* Out_channel wrapping socket. */
    mutable private_data: option('a),
    uuid: string /* UUID for this connection. */
  };

  type monad('a) = Thread.t('a);

  type isolation = [
    | `Serializable
    | `Repeatable_read
    | `Read_committed
    | `Read_uncommitted
  ];

  type access = [ | `Read_write | `Read_only];

  exception Error(string);

  exception PostgreSQL_Error(string, list((char, string)));

  /* If true, emit a lot of debugging information about the protocol on stderr.*/
  let debug_protocol = false;

  /*----- Code to generate messages for the back-end. -----*/

  let new_message = typ => {
    let buf = Buffer.create(128);
    (buf, Some(typ));
  };

  /* StartUpMessage and SSLRequest are special messages which don't
   * have a type byte field.
   */
  let new_start_message = () => {
    let buf = Buffer.create(128);
    (buf, None);
  };

  let add_byte = ((buf, _), i) =>
    /* Deliberately throw an exception if i isn't [0..255]. */
    Buffer.add_char(buf, Char.chr(i));

  let add_char = ((buf, _), c) => Buffer.add_char(buf, c);

  let add_int16 = ((buf, _), i) => {
    if (i < 0 || i > 65535) {
      raise(Error("PGOCaml: int16 is outside range [0..65535]."));
    };
    Buffer.add_char(buf, Char.unsafe_chr(i lsr 8 land 255));
    Buffer.add_char(buf, Char.unsafe_chr(i land 255));
  };

  let add_int32 = ((buf, _), i) => {
    let base = Int32.to_int(i);
    let big = Int32.to_int(Int32.shift_right_logical(i, 24));
    Buffer.add_char(buf, Char.unsafe_chr(big land 255));
    Buffer.add_char(buf, Char.unsafe_chr(base lsr 16 land 255));
    Buffer.add_char(buf, Char.unsafe_chr(base lsr 8 land 255));
    Buffer.add_char(buf, Char.unsafe_chr(base land 255));
  };

  let add_string_no_trailing_nil = ((buf, _), str) => {
    /* Check the string doesn't contain '\0' characters. */
    if (String.contains(str, '\000')) {
      raise(
        Error(
          sprintf("PGOCaml: string contains ASCII NIL character: %S", str),
        ),
      );
    };
    if (String.length(str) > 1073741823) {
      raise(Error("PGOCaml: string is too long."));
    };
    Buffer.add_string(buf, str);
  };

  let add_string = (msg, str) => {
    add_string_no_trailing_nil(msg, str);
    add_byte(msg, 0);
  };

  let send_message = ({chan, _}, (buf, typ)) => {
    /* Get the length in bytes. */
    let len = 4 + Buffer.length(buf);

    /* If the length is longer than a 31 bit integer, then the message is
     * too long to send.  This limits messages to 1 GB, which should be
     * enough for anyone :-)
     */
    if (Int64.of_int(len) >= 1073741824L) {
      raise(Error("PGOCaml: message is larger than 1 GB"));
    };

    if (debug_protocol) {
      eprintf(
        "> %s%d %S\n%!",
        switch (typ) {
        | None => ""
        | Some(c) => sprintf("%c ", c)
        },
        len,
        Buffer.contents(buf),
      );
    };

    /* Write the type byte? */
    (
      switch (typ) {
      | None => Thread.return()
      | Some(c) => output_char(chan, c)
      }
    )
    >>= (
      () =>
        /* Write the length field. */
        output_binary_int(chan, len)
        >>= (
          () =>
            /* Write the buffer. */
            output_string(chan, Buffer.contents(buf))
        )
    );
  };

  /* Max message length accepted from back-end. */
  let max_message_length = ref(Sys.max_string_length);

  /* Receive a single result message.  Parse out the message type,
   * message length, and binary message content.
   */
  let receive_raw_message = ({ichan, chan, _}) =>
    /* Flush output buffer. */
    flush(chan)
    >>= (
      () =>
        input_char(ichan)
        >>= (
          typ =>
            input_binary_int(ichan)
            >>= (
              len => {
                /* Discount the length word itself. */
                let len = len - 4;

                /* If the message is too long, give up now. */
                if (len > max_message_length^) {
                  /* Skip the message so we stay in synch with the stream. */
                  let bufsize = 65536;
                  let buf = Bytes.create(bufsize);
                  let rec loop = n =>
                    if (n > 0) {
                      let m = min(n, bufsize);
                      really_input(ichan, buf, 0, m) >>= (() => loop(n - m));
                    } else {
                      return();
                    };

                  loop(len)
                  >>= (
                    () =>
                      fail(
                        Error(
                          "PGOCaml: back-end message is longer than max_message_length",
                        ),
                      )
                  );
                } else {
                  /* Read the binary message content. */
                  let msg = Bytes.create(len);
                  really_input(ichan, msg, 0, len)
                  >>= (() => return((typ, Bytes.to_string(msg))));
                };
              }
            )
        )
    );

  /* Parse a back-end message. */
  type msg_t =
    | AuthenticationOk
    | AuthenticationKerberosV5
    | AuthenticationCleartextPassword
    | AuthenticationCryptPassword(string)
    | AuthenticationMD5Password(string)
    | AuthenticationSCMCredential
    | BackendKeyData(int32, int32)
    | BindComplete
    | CloseComplete
    | CommandComplete(string)
    | DataRow(list((int, string)))
    | EmptyQueryResponse
    | ErrorResponse(list((char, string)))
    | NoData
    | NoticeResponse(list((char, string)))
    | NotificationResponse
    | ParameterDescription(list(int32))
    | ParameterStatus(string, string)
    | ParseComplete
    | ReadyForQuery(char)
    | RowDescription(list((string, int32, int, int32, int, int32, int)))
    | UnknownMessage(char, string);

  let string_of_msg_t =
    fun
    | AuthenticationOk => "AuthenticationOk"
    | AuthenticationKerberosV5 => "AuthenticationKerberosV5"
    | AuthenticationCleartextPassword => "AuthenticationCleartextPassword"
    | AuthenticationCryptPassword(str) =>
      sprintf("AuthenticationCleartextPassword %S", str)
    | AuthenticationMD5Password(str) =>
      sprintf("AuthenticationMD5Password %S", str)
    | AuthenticationSCMCredential => "AuthenticationMD5Password"
    | [@implicit_arity] BackendKeyData(i1, i2) =>
      sprintf("BackendKeyData %ld, %ld", i1, i2)
    | BindComplete => "BindComplete"
    | CloseComplete => "CloseComplete"
    | CommandComplete(str) => sprintf("CommandComplete %S", str)
    | DataRow(fields) =>
      sprintf(
        "DataRow [%s]",
        String.concat(
          "; ",
          List.map(
            ((len, bytes)) => sprintf("%d, %S", len, bytes),
            fields,
          ),
        ),
      )
    | EmptyQueryResponse => "EmptyQueryResponse"
    | ErrorResponse(strs) =>
      sprintf(
        "ErrorResponse [%s]",
        String.concat(
          "; ",
          List.map(((k, v)) => sprintf("%c, %S", k, v), strs),
        ),
      )
    | NoData => "NoData"
    | NoticeResponse(strs) =>
      sprintf(
        "NoticeResponse [%s]",
        String.concat(
          "; ",
          List.map(((k, v)) => sprintf("%c, %S", k, v), strs),
        ),
      )
    | NotificationResponse => "NotificationResponse"
    | ParameterDescription(fields) =>
      sprintf(
        "ParameterDescription [%s]",
        String.concat("; ", List.map(oid => sprintf("%ld", oid), fields)),
      )
    | [@implicit_arity] ParameterStatus(s1, s2) =>
      sprintf("ParameterStatus %S, %S", s1, s2)
    | ParseComplete => "ParseComplete"
    | ReadyForQuery(c) =>
      sprintf(
        "ReadyForQuery %s",
        switch (c) {
        | 'I' => "Idle"
        | 'T' => "inTransaction"
        | 'E' => "Error"
        | c => sprintf("unknown(%c)", c)
        },
      )
    | RowDescription(fields) =>
      sprintf(
        "RowDescription [%s]",
        String.concat(
          "; ",
          List.map(
            ((name, table, col, oid, len, modifier, format)) =>
              sprintf(
                "%s %ld %d %ld %d %ld %d",
                name,
                table,
                col,
                oid,
                len,
                modifier,
                format,
              ),
            fields,
          ),
        ),
      )
    | [@implicit_arity] UnknownMessage(typ, msg) =>
      sprintf("UnknownMessage %c, %S", typ, msg);

  let parse_backend_message = ((typ, msg)) => {
    let pos = ref(0);
    let len = String.length(msg);

    /* Functions to grab the next object from the string 'msg'. */
    let get_char = where =>
      if (pos^ < len) {
        let r = msg.[pos^];
        incr(pos);
        r;
      } else {
        raise(
          Error(
            "PGOCaml: parse_backend_message: " ++ where ++ ": short message",
          ),
        );
      };

    let get_byte = where => Char.code(get_char(where));
    let get_int16 = () => {
      let r0 = get_byte("get_int16");
      let r1 = get_byte("get_int16");
      r0 lsr 8 + r1;
    };

    let get_int32 = () => {
      let r0 = get_byte("get_int32");
      let r1 = get_byte("get_int32");
      let r2 = get_byte("get_int32");
      let r3 = get_byte("get_int32");
      let r = Int32.of_int(r0);
      let r = Int32.shift_left(r, 8);
      let r = Int32.logor(r, Int32.of_int(r1));
      let r = Int32.shift_left(r, 8);
      let r = Int32.logor(r, Int32.of_int(r2));
      let r = Int32.shift_left(r, 8);
      let r = Int32.logor(r, Int32.of_int(r3));
      r;
    };

    /*let get_int64 () =
        let r0 = get_byte "get_int64" in
        let r1 = get_byte "get_int64" in
        let r2 = get_byte "get_int64" in
        let r3 = get_byte "get_int64" in
        let r4 = get_byte "get_int64" in
        let r5 = get_byte "get_int64" in
        let r6 = get_byte "get_int64" in
        let r7 = get_byte "get_int64" in
        let r = Int64.of_int r0 in
        let r = Int64.shift_left r 8 in
        let r = Int64.logor r (Int64.of_int r1) in
        let r = Int64.shift_left r 8 in
        let r = Int64.logor r (Int64.of_int r2) in
        let r = Int64.shift_left r 8 in
        let r = Int64.logor r (Int64.of_int r3) in
        let r = Int64.shift_left r 8 in
        let r = Int64.logor r (Int64.of_int r4) in
        let r = Int64.shift_left r 8 in
        let r = Int64.logor r (Int64.of_int r5) in
        let r = Int64.shift_left r 8 in
        let r = Int64.logor r (Int64.of_int r6) in
        let r = Int64.shift_left r 8 in
        let r = Int64.logor r (Int64.of_int r7) in
        r
      in*/
    let get_string = () => {
      let buf = Buffer.create(16);
      let rec loop = () => {
        let c = get_char("get_string");
        if (c != '\000') {
          Buffer.add_char(buf, c);
          loop();
        } else {
          Buffer.contents(buf);
        };
      };

      loop();
    };

    let get_n_bytes = n => String.init(n, _ => get_char("get_n_bytes"));
    let get_char = () => get_char("get_char");
    /*let get_byte () = get_byte "get_byte" in*/

    let msg =
      switch (typ) {
      | 'R' =>
        let t = get_int32();
        switch (t) {
        | 0l => AuthenticationOk
        | 2l => AuthenticationKerberosV5
        | 3l => AuthenticationCleartextPassword
        | 4l =>
          let salt = String.init(2, _ => get_char());
          AuthenticationCryptPassword(salt);
        | 5l =>
          let salt = String.init(4, _ => get_char());
          AuthenticationMD5Password(salt);
        | 6l => AuthenticationSCMCredential
        | _ => [@implicit_arity] UnknownMessage(typ, msg)
        };

      | 'E' =>
        let strs = ref([]);
        let rec loop = () => {
          let field_type = get_char();
          if (field_type == '\000') {
            List.rev(strs^);
          } else {
            /* end of list */

            strs := [(field_type, get_string()), ...strs^];
            loop();
          };
        };

        ErrorResponse(loop());

      | 'N' =>
        let strs = ref([]);
        let rec loop = () => {
          let field_type = get_char();
          if (field_type == '\000') {
            List.rev(strs^);
          } else {
            /* end of list */

            strs := [(field_type, get_string()), ...strs^];
            loop();
          };
        };

        NoticeResponse(loop());

      | 'A' => NotificationResponse

      | 'Z' =>
        let c = get_char();
        ReadyForQuery(c);

      | 'K' =>
        let pid = get_int32();
        let key = get_int32();
        [@implicit_arity] BackendKeyData(pid, key);

      | 'S' =>
        let param = get_string();
        let value = get_string();
        [@implicit_arity] ParameterStatus(param, value);

      | '1' => ParseComplete

      | '2' => BindComplete

      | '3' => CloseComplete

      | 'C' =>
        let str = get_string();
        CommandComplete(str);

      | 'D' =>
        let nr_fields = get_int16();
        let fields = ref([]);
        for (_ in 0 to nr_fields - 1) {
          let len = get_int32();
          let field =
            if (len < 0l) {
              ((-1), "");
            } else {
              if (len >= 1073741824l) {
                raise(Error("PGOCaml: result field is too long"));
              };
              let len = Int32.to_int(len);
              if (len > Sys.max_string_length) {
                raise(Error("PGOCaml: result field is too wide for string"));
              };
              let bytes = get_n_bytes(len);
              (len, bytes);
            };
          fields := [field, ...fields^];
        };
        DataRow(List.rev(fields^));

      | 'I' => EmptyQueryResponse

      | 'n' => NoData

      | 'T' =>
        let nr_fields = get_int16();
        let fields = ref([]);
        for (_ in 0 to nr_fields - 1) {
          let name = get_string();
          let table = get_int32();
          let column = get_int16();
          let oid = get_int32();
          let length = get_int16();
          let modifier = get_int32();
          let format = get_int16();
          fields :=
            [
              (name, table, column, oid, length, modifier, format),
              ...fields^,
            ];
        };
        RowDescription(List.rev(fields^));

      | 't' =>
        let nr_fields = get_int16();
        let fields = ref([]);
        for (_ in 0 to nr_fields - 1) {
          let oid = get_int32();
          fields := [oid, ...fields^];
        };
        ParameterDescription(List.rev(fields^));

      | _ => [@implicit_arity] UnknownMessage(typ, msg)
      };

    if (debug_protocol) {
      eprintf("< %s\n%!", string_of_msg_t(msg));
    };

    msg;
  };

  let rec receive_message = conn =>
    receive_raw_message(conn)
    >>= (
      msg =>
        switch (parse_backend_message(msg)) {
        | ParameterStatus(_)
        | NoticeResponse(_)
        | NotificationResponse =>
          /* Skip asynchronous messages */
          receive_message(conn)
        | msg => return(msg)
        }
    );

  /* Send a message and expect a single result. */
  let send_recv = (conn, msg) =>
    send_message(conn, msg) >>= (() => receive_message(conn));

  let verbose = ref(1);

  type severity =
    | ERROR
    | FATAL
    | PANIC
    | WARNING
    | NOTICE
    | DEBUG
    | INFO
    | LOG;

  let get_severity = fields => {
    let field =
      try(List.assoc('V', fields)) {
      /* introduced with PostgreSQL 9.6 */
      | Not_found => List.assoc('S', fields)
      };

    switch (field) {
    | "ERROR" => ERROR
    | "FATAL" => FATAL
    | "PANIC" => PANIC
    | "WARNING" => WARNING
    | "NOTICE" => NOTICE
    | "DEBUG" => DEBUG
    | "INFO" => INFO
    | "LOG" => LOG
    | _ => raise(Not_found)
    };
  };

  let show_severity =
    fun
    | ERROR => "ERROR"
    | FATAL => "FATAL"
    | PANIC => "PANIC"
    | WARNING => "WARNING"
    | NOTICE => "NOTICE"
    | DEBUG => "DEBUG"
    | INFO => "INFO"
    | LOG => "LOG";

  /* Print an ErrorResponse on stderr. */
  let print_ErrorResponse = fields => {
    if (verbose^ >= 1) {
      try({
        let severity =
          try(Some(get_severity(fields))) {
          | Not_found => None
          };
        let severity_string =
          switch (severity) {
          | Some(s) => show_severity(s)
          | None => "UNKNOWN"
          };

        let code = List.assoc('C', fields);
        let message = List.assoc('M', fields);
        if (verbose^ == 1) {
          switch (severity) {
          | Some(ERROR)
          | Some(FATAL)
          | Some(PANIC) =>
            eprintf("%s: %s: %s\n%!", severity_string, code, message)
          | _ => ()
          };
        } else {
          eprintf("%s: %s: %s\n%!", severity_string, code, message);
        };
      }) {
      | Not_found =>
        eprintf(
          "WARNING: 'Always present' field is missing in error message\n%!",
        )
      };
    };
    if (verbose^ >= 2) {
      List.iter(
        ((field_type, field)) =>
          if (field_type != 'S' && field_type != 'C' && field_type != 'M') {
            eprintf("%c: %s\n%!", field_type, field);
          },
        fields,
      );
    };
  };

  let sync_msg = conn => {
    let msg = new_message('S');
    send_message(conn, msg);
  };

  /* Handle an ErrorResponse anywhere, by printing and raising an exception. */
  let pg_error = (~conn=?, fields) => {
    print_ErrorResponse(fields);
    let str =
      try({
        let severity_string =
          try(show_severity @@ get_severity(fields)) {
          | Not_found => "UNKNOWN"
          };

        let code = List.assoc('C', fields);
        let message = List.assoc('M', fields);
        sprintf("%s: %s: %s", severity_string, code, message);
      }) {
      | Not_found => "WARNING: 'Always present' field is missing in error message"
      };

    /* If conn parameter was given, then resynch - read messages until we
     * see ReadyForQuery.
     */
    (
      switch (conn) {
      | None => return()
      | Some(conn) =>
        let rec loop = () =>
          receive_message(conn)
          >>= (
            msg =>
              switch (msg) {
              | ReadyForQuery(_) => return()
              | _ => loop()
              }
          );

        loop();
      }
    )
    >>= (() => fail([@implicit_arity] PostgreSQL_Error(str, fields)));
  };

  /*----- Profiling. -----*/

  type retexn('a) =
    | Ret('a)
    | Exn(exn);

  /* profile_op :
   *   string -> string -> string list -> (unit -> 'a Thread.t) -> 'a Thread.t
   */
  let profile_op = (uuid, op, detail, f) => {
    let chan =
      try({
        let filename = Sys.getenv("PGPROFILING");
        let flags = [Open_wronly, Open_append, Open_creat];
        let chan = open_out_gen(flags, 420, filename);
        Some(chan);
      }) {
      | Not_found
      | Sys_error(_) => None
      };
    switch (chan) {
    | None => f() /* No profiling - just run it. */
    | Some(chan) =>
      /* Profiling. */
      let start_time = Unix.gettimeofday();
      catch(() => f() >>= (x => return(Ret(x))), exn => return(Exn(exn)))
      >>= (
        ret => {
          let end_time = Unix.gettimeofday();

          let elapsed_time_ms =
            int_of_float(1000. *. (end_time -. start_time));
          let row =
            [
              "1", /* Version number. */
              uuid,
              op,
              string_of_int(elapsed_time_ms),
              switch (ret) {
              | Ret(_) => "ok"
              | Exn(exn) => Printexc.to_string(exn)
              },
            ]
            @ detail;

          /* Lock the output channel while we write the row, to prevent
           * corruption from multiple writers.
           */
          let fd = Unix.descr_of_out_channel(chan);
          Unix.lockf(fd, Unix.F_LOCK, 0);
          /* Csv.output_all(Csv.to_channel(chan), [row]); */
          close_out(chan);

          /* Return result or re-raise the exception. */
          switch (ret) {
          | Ret(r) => return(r)
          | Exn(exn) => fail(exn)
          };
        }
      );
    };
  };

  /*----- Connection. -----*/

  let pgsql_socket = (dir, port) => {
    let sockaddr = sprintf("%s/.s.PGSQL.%d", dir, port);
    Unix.ADDR_UNIX(sockaddr);
  };

  let describe_connection =
      (
        ~host=?,
        ~port=?,
        ~user=?,
        ~password=?,
        ~database=?,
        ~unix_domain_socket_dir=?,
        (),
      ) => {
    /* Get the username. */
    let user =
      switch (user) {
      | Some(user) => user
      | None =>
        try(Sys.getenv("PGUSER")) {
        | Not_found =>
          try({
            let pw = Unix.getpwuid(Unix.geteuid());
            pw.Unix.pw_name;
          }) {
          | Not_found => PGOCaml_config.default_user
          }
        }
      };

    /* Get the password. */
    let password =
      switch (password) {
      | Some(password) => password
      | None =>
        try(Sys.getenv("PGPASSWORD")) {
        | Not_found => PGOCaml_config.default_password
        }
      };

    /* Get the database name. */
    let database =
      switch (database) {
      | Some(database) => database
      | None =>
        try(Sys.getenv("PGDATABASE")) {
        | Not_found => user
        }
      };

    /* Hostname and port number. */
    let host =
      switch (host, unix_domain_socket_dir) {
      | (Some(_), Some(_)) =>
        raise(
          Failure(
            "describe_connection: it's invalid to specify both a HOST and a unix domain socket directory",
          ),
        )
      | (Some(s), None) when String.length(s) > 0 && s.[0] == '/' =>
        `Unix_domain_socket_dir(s)
      | (Some(s), None) => `Hostname(s)
      | (None, Some(s)) => `Unix_domain_socket_dir(s)
      | (None, None) =>
        try(`Hostname(Sys.getenv("PGHOST"))) {
        | Not_found =>
          /* fall back on Unix domain socket. */
          `Unix_domain_socket_dir(
            PGOCaml_config.default_unix_domain_socket_dir,
          )
        }
      };

    let port =
      switch (port) {
      | Some(port) => port
      | None =>
        try(int_of_string(Sys.getenv("PGPORT"))) {
        | Not_found
        | Failure(_) => PGOCaml_config.default_port
        }
      };

    {user, host, port, database, password};
  };

  /** We need to convert keys to a human-readable format for error reporting.
  */

  let connection_desc_to_string = key =>
    Printf.sprintf(
      "host=%s, port=%s, user=%s, password=%s, database=%s",
      switch (key.host) {
      | `Unix_domain_socket_dir(_) => "unix"
      | `Hostname(s) => s
      },
      string_of_int(key.port),
      key.user,
      "*****", /* we don't want to be dumping passwords into error logs */
      key.database,
    );

  let connect =
      (
        ~host=?,
        ~port=?,
        ~user=?,
        ~password=?,
        ~database=?,
        ~unix_domain_socket_dir=?,
        ~desc=?,
        (),
      ) => {
    let {user, host, port, database, password} =
      switch (desc) {
      | None =>
        describe_connection(
          ~host?,
          ~port?,
          ~user?,
          ~password?,
          ~database?,
          ~unix_domain_socket_dir?,
          (),
        )
      | Some(desc) => desc
      };

    /* Make the socket address. */
    let sockaddrs =
      switch (host) {
      | `Hostname(hostname) =>
        let addrs =
          Unix.getaddrinfo(
            hostname,
            sprintf("%d", port),
            [Unix.AI_SOCKTYPE(Unix.SOCK_STREAM)],
          );
        if (addrs == []) {
          raise(Error("PGOCaml: unknown host: " ++ hostname));
        } else {
          List.map(({Unix.ai_addr: sockaddr, _}) => sockaddr, addrs);
        };
      | `Unix_domain_socket_dir(udsd) =>
        /* Unix domain socket. */
        [pgsql_socket(udsd, port)]
      };

    /* Create a universally unique identifier for this connection.  This
     * is mainly for debugging and profiling.
     */
    let uuid = {
      /*
       * On Windows, the result of Unix.getpid is largely meaningless (it's not unique)
       * and, more importantly, Unix.getppid is not implemented.
       */
      let ppid =
        try(Unix.getppid()) {
        | Invalid_argument(_) => 0
        };

      sprintf(
        "%s %d %d %g %s %g",
        Unix.gethostname(),
        Unix.getpid(),
        ppid,
        Unix.gettimeofday(),
        Sys.executable_name,
        Unix.times().Unix.tms_utime,
      );
    };
    let uuid = Digest.to_hex(Digest.string(uuid));

    let sock_channels = {
      let rec create_sock_channels = sockaddrs =>
        switch (sockaddrs) {
        | [] => raise(Error("PGOCaml: Could not connect to database"))
        | [sockaddr, ...sockaddrs] =>
          catch(
            () => open_connection(sockaddr),
            fun
            | Unix.Unix_error(_) => create_sock_channels(sockaddrs)
            | exn => raise(exn),
          )
        };

      create_sock_channels(sockaddrs);
    };

    let do_connect = () =>
      sock_channels
      >>= (
        ((ichan, chan)) =>
          catch(
            () => {
              /* Create the connection structure. */
              let conn = {ichan, chan, private_data: None, uuid};

              /* Send the StartUpMessage.  NB. At present we do not support SSL. */
              let msg = new_start_message();
              add_int32(msg, 196608l);
              add_string(msg, "user");
              add_string(msg, user);
              add_string(msg, "database");
              add_string(msg, database);
              add_byte(msg, 0);

              /* Loop around here until the database gives a ReadyForQuery message. */
              let rec loop = msg =>
                (
                  switch (msg) {
                  | Some(msg) => send_recv(conn, msg)
                  | None => receive_message(conn)
                  }
                )
                >>= (
                  msg =>
                    switch (msg) {
                    | ReadyForQuery(_) => return() /* Finished connecting! */
                    | BackendKeyData(_) =>
                      /* XXX We should save this key. */
                      loop(None)
                    | AuthenticationOk => loop(None)
                    | AuthenticationKerberosV5 =>
                      fail(
                        Error(
                          "PGOCaml: Kerberos authentication not supported",
                        ),
                      )
                    | AuthenticationCleartextPassword =>
                      let msg = new_message('p'); /* PasswordMessage */
                      add_string(msg, password);
                      loop(Some(msg));
                    | AuthenticationCryptPassword(_salt) =>
                      /* Crypt password not supported because there is no crypt(3) function
                       * in OCaml.
                       */
                      fail(
                        Error(
                          "PGOCaml: crypt password authentication not supported",
                        ),
                      )
                    | AuthenticationMD5Password(salt) =>
                      /*	(* This is a guess at how the salt is used ... *)
                         let password = salt ^ password in
                         let password = Digest.string password in*/
                      let password =
                        "md5"
                        ++ Digest.to_hex(
                             Digest.string(
                               Digest.to_hex(Digest.string(password ++ user))
                               ++ salt,
                             ),
                           );
                      let msg = new_message('p'); /* PasswordMessage */
                      add_string(msg, password);
                      loop(Some(msg));
                    | AuthenticationSCMCredential =>
                      fail(
                        Error(
                          "PGOCaml: SCM Credential authentication not supported",
                        ),
                      )
                    | ErrorResponse(err) => pg_error(err)
                    | _ =>
                      /* Silently ignore unknown or unexpected message types. */
                      loop(None)
                    }
                );

              loop(Some(msg)) >>= (() => return(conn));
            },
            e => close_in(ichan) >>= (() => fail(e)),
          )
      );

    let detail = [
      "user",
      user,
      "database",
      database,
      "host",
      switch (host) {
      | `Unix_domain_socket_dir(_) => "unix"
      | `Hostname(s) => s
      },
      "port",
      string_of_int(port),
      "prog",
      Sys.executable_name,
    ];
    profile_op(uuid, "connect", detail, do_connect);
  };

  let close = conn => {
    let do_close = () =>
      catch(
        () => {
          /* Be nice and send the terminate message. */
          let msg = new_message('X');
          send_message(conn, msg)
          >>= (() => flush(conn.chan) >>= (() => return(None)));
        },
        e => return(Some(e)),
      )
      >>= (
        e =>
          /* Closes the underlying socket too. */
          close_in(conn.ichan)
          >>= (
            () =>
              switch (e) {
              | None => return()
              | Some(e) => fail(e)
              }
          )
      );

    profile_op(conn.uuid, "close", [], do_close);
  };

  let set_private_data = (conn, data) => conn.private_data = Some(data);

  let private_data = ({private_data, _}) =>
    switch (private_data) {
    | None => raise(Not_found)
    | Some(private_data) => private_data
    };

  let uuid = conn => conn.uuid;

  type pa_pg_data = Hashtbl.t(string, bool);

  let ping = conn => {
    let do_ping = () =>
      sync_msg(conn)
      >>= (
        () => {
          /* Wait for ReadyForQuery. */
          let rec loop = () =>
            receive_message(conn)
            >>= (
              msg =>
                switch (msg) {
                | ReadyForQuery(_) => return() /* Finished! */
                | ErrorResponse(err) => pg_error(~conn, err) /* Error */
                | _ => loop()
                }
            );

          loop();
        }
      );

    profile_op(conn.uuid, "ping", [], do_ping);
  };

  let alive = conn =>
    catch(() => ping(conn) >>= (() => return(true)), _ => return(false));

  [@deriving show]
  type oid = int32;

  type param = option(string);
  type result = option(string);
  type row = list(result);

  let prepare = (conn, ~query, ~name="", ~types=[], ()) => {
    let do_prepare = () => {
      let msg = new_message('P');
      add_string(msg, name);
      add_string(msg, query);
      add_int16(msg, List.length(types));
      List.iter(add_int32(msg), types);
      send_message(conn, msg)
      >>= (
        () =>
          sync_msg(conn)
          >>= (
            () => {
              let rec loop = () =>
                receive_message(conn)
                >>= (
                  msg =>
                    switch (msg) {
                    | ErrorResponse(err) => pg_error(~conn, err)
                    | ParseComplete => loop()
                    | ReadyForQuery(_) => return() /* Finished! */
                    | _ =>
                      fail(
                        Error(
                          "PGOCaml: unknown response from parse: "
                          ++ string_of_msg_t(msg),
                        ),
                      )
                    }
                );

              loop();
            }
          )
      );
    };

    let details = ["query", query, "name", name];
    profile_op(conn.uuid, "prepare", details, do_prepare);
  };

  let iter_execute = (conn, name, portal, params, proc, ()) => {
    /* Bind */
    let msg = new_message('B');
    add_string(msg, portal);
    add_string(msg, name);
    add_int16(msg, 0); /* Send all parameters as text. */
    add_int16(msg, List.length(params));
    List.iter(
      param =>
        switch (param) {
        | None => add_int32(msg, -1l) /* NULL */
        | Some(str) =>
          add_int32(msg, Int32.of_int(String.length(str)));
          add_string_no_trailing_nil(msg, str);
        },
      params,
    );
    add_int16(msg, 0); /* Send back all results as text. */
    send_message(conn, msg)
    >>= (
      () => {
        /* Execute */
        let msg = new_message('E');
        add_string(msg, portal);
        add_int32(msg, 0l); /* no limit on rows */
        send_message(conn, msg)
        >>= (
          () =>
            /* Sync */
            sync_msg(conn)
            >>= (
              () => {
                /* Process the message(s) received from the database until we read
                 * ReadyForQuery.  In the process we may get some rows back from
                 * the database, no data, or an error.
                 */
                let rec loop = () =>
                  /* NB: receive_message flushes the output connection. */
                  receive_message(conn)
                  >>= (
                    msg =>
                      switch (msg) {
                      | ReadyForQuery(_) => return() /* Finished! */
                      | ErrorResponse(err) => pg_error(~conn, err) /* Error */
                      | BindComplete => loop()
                      | CommandComplete(_) => loop()
                      | EmptyQueryResponse => loop()
                      | DataRow(fields) =>
                        let fields =
                          List.map(
                            fun
                            | (i, _) when i < 0 => None /* NULL */
                            | (0, _) => Some("")
                            | (_, bytes) => Some(bytes),
                            fields,
                          );
                        proc(fields) >>= loop;
                      | NoData => loop()
                      | _ =>
                        fail(
                          Error(
                            "PGOCaml: unknown response message: "
                            ++ string_of_msg_t(msg),
                          ),
                        )
                      }
                  );

                loop();
              }
            )
        );
      }
    );
  };

  let do_execute = (conn, name, portal, params, rev, ()) => {
    let rows = ref([]);
    iter_execute(
      conn,
      name,
      portal,
      params,
      fields => return(rows := [fields, ...rows^]),
      (),
    )
    >>= (
      () =>
        /* Return the result rows. */
        return(
          if (rev) {
            List.rev(rows^);
          } else {
            rows^;
          },
        )
    );
  };

  let execute_rev = (conn, ~name="", ~portal="", ~params, ()) => {
    let do_execute = do_execute(conn, name, portal, params, false);
    let details = ["name", name, "portal", portal];
    profile_op(conn.uuid, "execute", details, do_execute);
  };

  let execute = (conn, ~name="", ~portal="", ~params, ()) => {
    let do_execute = do_execute(conn, name, portal, params, true);
    let details = ["name", name, "portal", portal];
    profile_op(conn.uuid, "execute", details, do_execute);
  };

  let cursor = (conn, ~name="", ~portal="", ~params, proc) => {
    let do_execute = iter_execute(conn, name, portal, params, proc);
    let details = ["name", name, "portal", portal];
    profile_op(conn.uuid, "cursor", details, do_execute);
  };

  let begin_work = (~isolation=?, ~access=?, ~deferrable=?, conn) => {
    let isolation_str =
      switch (isolation) {
      | None => ""
      | Some(x) =>
        " isolation level "
        ++ (
          switch (x) {
          | `Serializable => "serializable"
          | `Repeatable_read => "repeatable read"
          | `Read_committed => "read committed"
          | `Read_uncommitted => "read uncommitted"
          }
        )
      };
    let access_str =
      switch (access) {
      | None => ""
      | Some(x) =>
        switch (x) {
        | `Read_write => " read write"
        | `Read_only => " read only"
        }
      };
    let deferrable_str =
      switch (deferrable) {
      | None => ""
      | Some(x) => (x ? "" : " not") ++ " deferrable"
      };
    let query = "begin work" ++ isolation_str ++ access_str ++ deferrable_str;
    prepare(conn, ~query, ())
    >>= (() => execute(conn, ~params=[], ()) >>= (_ => return()));
  };

  let commit = conn => {
    let query = "commit";
    prepare(conn, ~query, ())
    >>= (() => execute(conn, ~params=[], ()) >>= (_ => return()));
  };

  let rollback = conn => {
    let query = "rollback";
    prepare(conn, ~query, ())
    >>= (() => execute(conn, ~params=[], ()) >>= (_ => return()));
  };

  let transact = (conn, ~isolation=?, ~access=?, ~deferrable=?, f) =>
    begin_work(~isolation?, ~access?, ~deferrable?, conn)
    >>= (
      () =>
        catch(
          () => f(conn) >>= (r => commit(conn) >>= (() => return(r))),
          e => rollback(conn) >>= (() => fail(e)),
        )
    );

  let serial = (conn, name) => {
    let query = "select currval ($1)";
    prepare(conn, ~query, ())
    >>= (
      () =>
        execute(conn, ~params=[Some(name)], ())
        >>= (
          rows => {
            let row = List.hd(rows);
            let result = List.hd(row);
            /* NB. According to the manual, the return type of currval is
             * always a bigint, whether or not the column is serial or bigserial.
             */
            return(Int64.of_string(Option.get(result)));
          }
        )
    );
  };

  let serial4 = (conn, name) =>
    serial(conn, name) >>= (s => return(Int64.to_int32(s)));

  let serial8 = serial;

  let close_statement = (conn, ~name="", ()) => {
    let msg = new_message('C');
    add_char(msg, 'S');
    add_string(msg, name);
    send_message(conn, msg)
    >>= (
      () =>
        sync_msg(conn)
        >>= (
          () => {
            let rec loop = () =>
              receive_message(conn)
              >>= (
                msg =>
                  switch (msg) {
                  | ErrorResponse(err) => pg_error(~conn, err)
                  | CloseComplete => loop()
                  | ReadyForQuery(_) => return() /* Finished! */
                  | _ =>
                    fail(
                      Error(
                        "PGOCaml: unknown response from close: "
                        ++ string_of_msg_t(msg),
                      ),
                    )
                  }
              );

            loop();
          }
        )
    );
  };

  let close_portal = (conn, ~portal="", ()) => {
    let msg = new_message('C');
    add_char(msg, 'P');
    add_string(msg, portal);
    send_message(conn, msg)
    >>= (
      () =>
        sync_msg(conn)
        >>= (
          () => {
            let rec loop = () =>
              receive_message(conn)
              >>= (
                msg =>
                  switch (msg) {
                  | ErrorResponse(err) => pg_error(~conn, err)
                  | CloseComplete => loop()
                  | ReadyForQuery(_) => return() /* Finished! */
                  | _ =>
                    fail(
                      Error(
                        "PGOCaml: unknown response from close: "
                        ++ string_of_msg_t(msg),
                      ),
                    )
                  }
              );

            loop();
          }
        )
    );
  };

  let inject = (db, ~name=?, query) =>
    prepare(db, ~query, ~name?, ())
    >>= (
      () =>
        execute(db, ~name?, ~params=[], ())
        >>= (ret => close_statement(db, ~name?, ()) >>= (() => return(ret)))
    );

  let alter = (db, ~name=?, query) =>
    inject(db, ~name?, query) >>= (_ => return());

  [@deriving show]
  type result_description = {
    name: string,
    table: option(oid),
    column: option(int),
    field_type: oid,
    length: int,
    modifier: int32,
  };
  [@deriving show]
  type row_description = list(result_description);

  type param_description = {param_type: oid};
  type params_description = list(param_description);

  let expect_rfq = (conn, ret) =>
    receive_message(conn)
    >>= (
      msg =>
        switch (msg) {
        | ReadyForQuery(_) => return(ret)
        | msg =>
          fail @@
          Error(
            "PGOCaml: unknown response from describe: "
            ++ string_of_msg_t(msg),
          )
        }
    );

  let describe_statement = (conn, ~name="", ()) => {
    let msg = new_message('D');
    add_char(msg, 'S');
    add_string(msg, name);
    send_message(conn, msg)
    >>= (
      () =>
        sync_msg(conn)
        >>= (
          () =>
            receive_message(conn)
            >>= (
              msg =>
                (
                  switch (msg) {
                  | ErrorResponse(err) => pg_error(~conn, err)
                  | ParameterDescription(params) =>
                    let params = List.map(oid => {param_type: oid}, params);
                    return(params);
                  | _ =>
                    fail(
                      Error(
                        "PGOCaml: unknown response from describe: "
                        ++ string_of_msg_t(msg),
                      ),
                    )
                  }
                )
                >>= (
                  params =>
                    receive_message(conn)
                    >>= (
                      msg =>
                        (
                          switch (msg) {
                          | ErrorResponse(err) => pg_error(~conn, err)
                          | NoData => return((params, None))
                          | RowDescription(fields) =>
                            let fields =
                              List.map(
                                (
                                  (
                                    name,
                                    table,
                                    column,
                                    oid,
                                    length,
                                    modifier,
                                    _,
                                  ),
                                ) =>
                                  {
                                    name,
                                    table:
                                      if (table == 0l) {
                                        None;
                                      } else {
                                        Some(table);
                                      },
                                    column:
                                      if (column == 0) {
                                        None;
                                      } else {
                                        Some(column);
                                      },
                                    field_type: oid,
                                    length,
                                    modifier,
                                  },
                                fields,
                              );
                            return((params, Some(fields)));
                          | _ =>
                            fail(
                              Error(
                                "PGOCaml: unknown response from describe: "
                                ++ string_of_msg_t(msg),
                              ),
                            )
                          }
                        )
                        >>= expect_rfq(conn)
                    )
                )
            )
        )
    );
  };

  let describe_portal = (conn, ~portal="", ()) => {
    let msg = new_message('D');
    add_char(msg, 'P');
    add_string(msg, portal);
    send_message(conn, msg)
    >>= (
      () =>
        sync_msg(conn)
        >>= (
          () =>
            receive_message(conn)
            >>= (
              msg =>
                (
                  switch (msg) {
                  | ErrorResponse(err) => pg_error(~conn, err)
                  | NoData => return(None)
                  | RowDescription(fields) =>
                    let fields =
                      List.map(
                        ((name, table, column, oid, length, modifier, _)) =>
                          {
                            name,
                            table:
                              if (table == 0l) {
                                None;
                              } else {
                                Some(table);
                              },
                            column:
                              if (column == 0) {
                                None;
                              } else {
                                Some(column);
                              },
                            field_type: oid,
                            length,
                            modifier,
                          },
                        fields,
                      );
                    return(Some(fields));
                  | _ =>
                    fail(
                      Error(
                        "PGOCaml: unknown response from describe: "
                        ++ string_of_msg_t(msg),
                      ),
                    )
                  }
                )
                >>= expect_rfq(conn)
            )
        )
    );
  };

  /*----- Type conversion. -----*/

  /* For certain types, more information is available by looking
   * at the modifier field as well as just the OID.  For example,
   * for NUMERIC the modifier tells us the precision.
   * However we don't always have the modifier field available -
   * in particular for parameters.
   */
  let name_of_type =
    fun
    | 16l => "bool" /* BOOLEAN */
    | 17l => "bytea" /* BYTEA */
    | 20l => "int64" /* INT8 */
    | 21l => "int16" /* INT2 */
    | 23l => "int32" /* INT4 */
    | 25l => "string" /* TEXT */
    | 114l => "string" /* JSON */
    | 119l => "string_array" /* JSON[] */
    | 600l => "point" /* POINT */
    | 700l
    | 701l => "float" /* FLOAT4, FLOAT8 */
    | 869l => "inet" /* INET */
    | 1000l => "bool_array" /* BOOLEAN[] */
    | 1001l => "bytea_array" /* BYTEA[] */
    | 1007l => "int32_array" /* INT4[] */
    | 1009l => "string_array" /* TEXT[] */
    | 1014l => "string_array" /* CHAR[] */
    | 1015l => "string_array" /* VARCHAR[] */
    | 1016l => "int64_array" /* INT8[] */
    | 1021l
    | 1022l => "float_array" /* FLOAT4[], FLOAT8[] */
    | 1042l => "string" /* CHAR(n) - treat as string */
    | 1043l => "string" /* VARCHAR(n) - treat as string */
    | 1082l => "date" /* DATE */
    | 1083l => "time" /* TIME */
    | 1114l => "timestamp" /* TIMESTAMP */
    | 1115l => "timestamp_array" /* TIMESTAMP[] */
    | 1184l => "timestamptz" /* TIMESTAMP WITH TIME ZONE */
    | 1186l => "interval" /* INTERVAL */
    | 2278l => "unit" /* VOID */
    | 1700l => "string" /* NUMERIC */
    | 2950l => "uuid" /* UUID */
    | 3802l => "string" /* JSONB */
    | 3807l => "string_array" /* JSONB[] */
    | i =>
      /* For unknown types, look at <postgresql/catalog/pg_type.h>. */
      raise(Error("PGOCaml: unknown type for OID " ++ Int32.to_string(i)));

  type inet = (Unix.inet_addr, int);
  type timestamptz = (Js.Date.t, Js.Date.t);
  type int16 = int;
  type bytea = string;
  type point = (float, float);
  type hstore = list((string, option(string)));
  type numeric = string;
  type uuid = string;
  type jsonb = string;

  type bool_array = list(option(bool));
  type int32_array = list(option(int32));
  type int64_array = list(option(int64));
  type string_array = list(option(string));
  type float_array = list(option(float));
  type timestamp_array = list(option(Js.Date.t));

  let string_of_hstore = hstore => {
    let string_of_quoted = str => "\"" ++ str ++ "\"";
    let string_of_mapping = ((key, value)) => {
      let key_str = string_of_quoted(key);
      let value_str =
        switch (value) {
        | Some(v) => string_of_quoted(v)
        | None => "NULL"
        };
      key_str ++ "=>" ++ value_str;
    };
    String.join(", ", List.map(string_of_mapping, hstore));
  };

  let string_of_numeric = (x: string) => x;

  let string_of_uuid = (x: string) => x;

  let string_of_jsonb = (x: string) => x;

  let string_of_inet = ((addr, mask)) => {
    let hostmask =
      if (Unix.domain_of_sockaddr([@implicit_arity] Unix.ADDR_INET(addr, 1))
          == Unix.PF_INET6) {
        128;
      } else {
        32;
      };

    let addr = Unix.string_of_inet_addr(addr);

    if (mask == hostmask) {
      addr;
    } else if (mask >= 0 && mask < hostmask) {
      addr ++ "/" ++ string_of_int(mask);
    } else {
      failwith("string_of_inet");
    };
  };

  let string_of_oid = Int32.to_string;
  let string_of_bool =
    fun
    | true => "t"
    | false => "f";
  let string_of_int = string_of_int;
  let string_of_int16 = string_of_int;
  let string_of_int32 = Int32.to_string;
  let string_of_int64 = Int64.to_string;
  let string_of_float = Js.Float.toString;
  let string_of_point = ((x, y)) =>
    "(" ++ string_of_float(x) ++ "," ++ string_of_float(y) ++ ")";
  let string_of_timestamp = Js.Date.toString;
  let string_of_timestamptz = Js.Date.toString;
  let string_of_date = Js.Date.toDateString;
  let string_of_time = Js.Date.toTimeString;
  let string_of_interval = Js.Date.toString;
  let string_of_unit = () => "";

  /* NB. It is the responsibility of the caller of this function to
   * properly escape array elements.
   */
  let string_of_any_array = xs => {
    let buf = Buffer.create(128);
    Buffer.add_char(buf, '{');
    let adder = (i, x) => {
      if (i > 0) {
        Buffer.add_char(buf, ',');
      };
      switch (x) {
      | Some(x) =>
        Buffer.add_char(buf, '"');
        Buffer.add_string(buf, x);
        Buffer.add_char(buf, '"');
      | None => Buffer.add_string(buf, "NULL")
      };
    };
    List.iteri(adder, xs);
    Buffer.add_char(buf, '}');
    Buffer.contents(buf);
  };

  let option_map = f =>
    fun
    | Some(x) => Some(f(x))
    | None => None;

  let escape_string = str => {
    let buf = Buffer.create(128);
    for (i in 0 to String.length(str) - 1) {
      switch (str.[i]) {
      | ('"' | '\\') as x =>
        Buffer.add_char(buf, '\\');
        Buffer.add_char(buf, x);
      | x => Buffer.add_char(buf, x)
      };
    };
    Buffer.contents(buf);
  };

  let string_of_bool_array = a =>
    string_of_any_array(List.map(option_map(string_of_bool), a));
  let string_of_int32_array = a =>
    string_of_any_array(List.map(option_map(Int32.to_string), a));
  let string_of_int64_array = a =>
    string_of_any_array(List.map(option_map(Int64.to_string), a));
  let string_of_string_array = a =>
    string_of_any_array(List.map(option_map(escape_string), a));
  let string_of_float_array = a =>
    string_of_any_array(List.map(option_map(string_of_float), a));
  let string_of_timestamp_array = a =>
    string_of_any_array(List.map(option_map(string_of_timestamp), a));
  let string_of_arbitrary_array = (f, a) =>
    string_of_any_array(List.map(option_map(f), a));

  let comment_src_loc = () =>
    switch (Sys.getenv_opt("PGCOMMENT_SRC_LOC")) {
    | Some(x) =>
      switch (x) {
      | "yes"
      | "1"
      | "on" => true
      | "no"
      | "0"
      | "off" => false
      | _ =>
        failwith(
          Printf.sprintf(
            "Unrecognized option for 'PGCOMMENT_SRC_LOC': %s",
            x,
          ),
        )
      }
    | None => PGOCaml_config.default_comment_src_loc
    };

  /* TODO
       open Sexplib.Std;
       [@deriving sexp]
       type custom_rule_payload = {
         serialize: string,
         deserialize: string,
       };

       [@deriving sexp]
       type custom_rule_spec =
         | Typnam(string)
         | Colnam(string)
         | Argnam(string);

       [@deriving sexp]
       type rule_logic =
         | And(list(rule_logic))
         | Or(list(rule_logic))
         | Rule(custom_rule_spec)
         | True
         | False;

       let rec eval_rule_spec = (~typnam=?, ~colnam=?, ~argnam=?, logic) =>
         switch (logic) {
         | True => true
         | False => false
         | Rule(Typnam(s)) => Option.(map((==)(s), typnam) |> default(false))
         | Rule(Colnam(s)) => Option.(map((==)(s), colnam) |> default(false))
         | Rule(Argnam(s)) => Option.(map((==)(s), argnam) |> default(false))
         | And(logics) =>
           [@warning "-8"]
           {
             let [hd, ...tl] =
               List.map(eval_rule_spec(~typnam?, ~colnam?, ~argnam?), logics);
             List.fold_left((acc, x) => acc && x, hd, tl);
           }
         | Or(logics) =>
           [@warning "-8"]
           {
             let [hd, ...tl] =
               List.map(eval_rule_spec(~typnam?, ~colnam?, ~argnam?), logics);
             List.fold_left((acc, x) => acc || x, hd, tl);
           }
         };

       [@deriving sexp]
       type custom_rule = (rule_logic, custom_rule_payload);

       [@deriving sexp]
       type custom_rules_conf = list(custom_rule);

       let find_custom_typconvs = {
         open Rresult;
         let loadconvs = fname =>
           try(
             Ok(Sexplib.Sexp.load_sexp_conv_exn(fname, custom_rules_conf_of_sexp))
           ) {
           | exn =>
             let cwd = Unix.getcwd();
             Error(
               Printf.sprintf(
                 "Error parsing custom typeconvs file in %s: %s",
                 cwd,
                 Printexc.to_string(exn),
               ),
             );
           };

         let default_custom_converters =
           switch (Sys.getenv_opt("PGCUSTOM_CONVERTERS_CONFIG")) {
           | None => Ok([])
           | Some(f) => loadconvs(f)
           };

         (~typnam=?, ~lookin=?, ~colnam=?, ~argnam=?, ()) =>
           (
             switch (lookin) {
             | Some(x) =>
               /*let _ = failwith ("Kill me now " ^ x) in*/
               let convs = loadconvs(x);
               switch (convs) {
               | Ok(x) => Ok(x)
               | Error(e) => Error(e)
               };
             /*>>= fun blep ->
               Error (Printf.sprintf "Got %d converters" (List.length @@ blep))*/
             | None => default_custom_converters
             }
           )
           >>= (
             custom_converters =>
               (
                 try(
                   Ok(
                     List.filter(
                       ((logic, _)) =>
                         eval_rule_spec(~typnam?, ~colnam?, ~argnam?, logic),
                       custom_converters,
                     ),
                   )
                 ) {
                 | Failure(e) => failwith(e)
                 }
               )
               >>= (
                 res =>
                   switch (res) {
                   | [_, _, ..._] => Error("Converter collision")
                   | [] => Ok(None)
                   | [(_rulespec, v)] => Ok(Some((v.serialize, v.deserialize)))
                   }
               )
           );
       };
     */
  /*
   let string_of_bytea = b => {
     let `Hex(b_hex) = Hex.of_string(b);
     "\\x" ++ b_hex;
   };

   let string_of_bytea_array = a =>
     string_of_any_array(List.map(option_map(string_of_bytea), a));
   */

  let string_of_string = (x: string) => x;
  let oid_of_string = Int32.of_string;
  let bool_of_string =
    fun
    | "true"
    | "t" => true
    | "false"
    | "f" => false
    | str => raise(Error("PGOCaml: not a boolean: " ++ str));
  let int_of_string = int_of_string;
  let int16_of_string = int_of_string;
  let int32_of_string = Int32.of_string;
  let int64_of_string = Int64.of_string;
  let float_of_string = float_of_string;

  let hstore_of_string = str => {
    let expect = (target, stream) =>
      if (List.exists(c => c != Stream.next(stream), target)) {
        raise(Error("PGOCaml: unexpected input in hstore_of_string"));
      };
    let parse_quoted = stream => {
      let rec loop = (accum, stream) =>
        switch (Stream.next(stream)) {
        | '"' => String.implode(List.rev(accum))
        | '\\' => loop([Stream.next(stream), ...accum], stream)
        | x => loop([x, ...accum], stream)
        };
      expect(['"'], stream);
      loop([], stream);
    };
    let parse_value = stream =>
      switch (Stream.peek(stream)) {
      | Some('N') =>
        expect(['N', 'U', 'L', 'L'], stream);
        None;
      | _ => Some(parse_quoted(stream))
      };
    let parse_mapping = stream => {
      let key = parse_quoted(stream);
      expect(['=', '>'], stream);
      let value = parse_value(stream);
      (key, value);
    };
    let parse_main = stream => {
      let rec loop = (accum, stream) => {
        let mapping = parse_mapping(stream);
        switch (Stream.peek(stream)) {
        | Some(_) =>
          expect([',', ' '], stream);
          loop([mapping, ...accum], stream);
        | None => [mapping, ...accum]
        };
      };
      switch (Stream.peek(stream)) {
      | Some(_) => loop([], stream)
      | None => []
      };
    };
    parse_main(Stream.of_string(str));
  };

  let numeric_of_string = (x: string) => x;

  let uuid_of_string = (x: string) => x;

  let jsonb_of_string = (x: string) => x;

  let inet_of_string = {
    /* TODO
       let re =
         Re.(
           [
             group(
               [
                 rep(compl([set(":./")])),
                 group(set(":.")),
                 rep1(compl([char('/')])),
               ]
               |> seq,
             ),
             opt(seq([char('/'), group(rep1(any))])),
           ]
           |> seq
           |> compile
         );
       str => {
         let subs = Re.exec(re, str);
         let addr = Unix.inet_addr_of_string(Re.Group.get(subs, 1));
         let mask =
           try(Re.Group.get(subs, 3)) {
           | Not_found => ""
           }; /* optional match */
         if (mask == "") {
           (
             addr,
             if (Re.Group.get(subs, 2) == ".") {
               32;
             } else {
               128;
             },
           );
         } else {
           (addr, int_of_string(mask));
         };
       };
       */
  };

  let point_of_string = {
    /* TODO
       let point_re = {
         open Re;
         let space = p => {
           let space = rep(set(" \t"));
           seq([space, p, space]);
         };
         let sign = opt(set("+-"));
         let num =
           seq([
             sign,
             rep1(digit),
             opt(char('.')),
             rep(digit),
             opt(seq([set("Ee"), set("+-"), rep1(digit)])),
           ]);
         let nan = seq([set("Nn"), char('a'), set("Nn")]);
         let inf = seq([sign, set("Ii"), str("nfinity")]);
         let float_pat = Re.alt([num, nan, inf]);
         [
           char('('),
           space(group(float_pat)),
           char(','),
           space(group(float_pat)),
           char(')'),
         ]
         |> seq
         |> compile;
       };
       str =>
         try({
           let subs = Re.exec(point_re, str);
           (
             float_of_string(Re.Group.get(subs, 1)),
             float_of_string(Re.Group.get(subs, 2)),
           );
         }) {
         | _ => failwith("point_of_string")
         };
         */
  };

  let date_of_string = Js.Date.fromString;

  let time_of_string = Js.Date.fromString;

  let timestamp_of_string = Js.Date.fromString;

  let timestamptz_of_string = Js.Date.fromString;

  /* TODO
     let re_interval = {
       open Re;
       let time_period = unit_name =>
         [group(rep1(digit)), space, str(unit_name), opt(char('s'))]
         |> seq
         |> opt;
       let digit2 = [digit, digit] |> seq |> group;
       let time =
         seq([digit2, char(':'), digit2, opt(seq([char(':'), digit2]))]);
       [
         opt(time_period("year")),
         rep(space),
         opt(time_period("mon")),
         rep(space),
         opt(time_period("day")),
         rep(space),
         opt(time),
       ]
       |> seq
       |> compile;
     };

     let interval_of_string = {
       let int_opt = (subs, i) =>
         try(int_of_string(Re.Group.get(subs, i))) {
         | Not_found => 0
         };
       str =>
         try({
           let sub = Re.exec(re_interval, str);
           Calendar.Period.make(
             int_opt(sub, 1), /* year */
             int_opt(sub, 2), /* month */
             int_opt(sub, 3), /* day */
             int_opt(sub, 4), /* hour */
             int_opt(sub, 5), /* min */
             int_opt(sub, 6),
           );
         }) {
         /* sec */

         | Not_found => failwith("interval_of_string: bad interval: " ++ str)
         };
     };
     */

  let unit_of_string = _ => ();

  /* NB. This function also takes care of unescaping returned elements. */
  let any_array_of_string = str => {
    let n = String.length(str);
    assert(str.[0] == '{');
    assert(str.[n - 1] == '}');
    let str = String.sub(str, 1, n - 2);
    let buf = Buffer.create(128);
    let add_field = accum => {
      let x = Buffer.contents(buf);
      Buffer.clear(buf);
      let field =
        if (x == "NULL") {
          None;
        } else {
          let n = String.length(x);
          if (n >= 2 && x.[0] == '"') {
            Some(String.sub(x, 1, n - 2));
          } else {
            Some(x);
          };
        };
      [field, ...accum];
    };
    let loop = ((accum, quoted, escaped)) =>
      fun
      | '\\' when !escaped => (accum, quoted, true)
      | '"' when !escaped => {
          Buffer.add_char(buf, '"');
          (accum, !quoted, false);
        }
      | ',' when !escaped && !quoted => (add_field(accum), false, false)
      | x => {
          Buffer.add_char(buf, x);
          (accum, quoted, false);
        };
    let (accum, _, _) = String.fold_left(loop, ([], false, false), str);
    let accum =
      if (Buffer.length(buf) == 0) {
        accum;
      } else {
        add_field(accum);
      };
    List.rev(accum);
  };

  let bool_array_of_string = str =>
    List.map(option_map(bool_of_string), any_array_of_string(str));
  let int32_array_of_string = str =>
    List.map(option_map(Int32.of_string), any_array_of_string(str));
  let int64_array_of_string = str =>
    List.map(option_map(Int64.of_string), any_array_of_string(str));
  let string_array_of_string = str => any_array_of_string(str);
  let float_array_of_string = str =>
    List.map(option_map(float_of_string), any_array_of_string(str));
  let timestamp_array_of_string = str =>
    List.map(option_map(timestamp_of_string), any_array_of_string(str));
  let arbitrary_array_of_string = (f, str) =>
    List.map(option_map(f), any_array_of_string(str));

  let is_first_oct_digit = c => c >= '0' && c <= '3';
  let is_oct_digit = c => c >= '0' && c <= '7';
  let oct_val = c => Char.code(c) - 48;

  let is_hex_digit =
    fun
    | '0'..'9'
    | 'a'..'f'
    | 'A'..'F' => true
    | _ => false;

  let hex_val = c => {
    let offset =
      switch (c) {
      | '0'..'9' => 48
      | 'a'..'f' => 87
      | 'A'..'F' => 55
      | _ => failwith("hex_val")
      };
    Char.code(c) - offset;
  };

  /* Deserialiser for the new 'hex' format introduced in PostgreSQL 9.0. */
  let bytea_of_string_hex = str => {
    let len = String.length(str);
    let buf = Buffer.create((len - 2) / 2);
    let i = ref(3);
    while (i^ < len) {
      let hi_nibble = str.[i^ - 1];
      let lo_nibble = str.[i^];
      i := i^ + 2;
      if (is_hex_digit(hi_nibble) && is_hex_digit(lo_nibble)) {
        let byte = hex_val(hi_nibble) lsl 4 + hex_val(lo_nibble);
        Buffer.add_char(buf, Char.chr(byte));
      };
    };
    Buffer.contents(buf);
  };

  /* Deserialiser for the old 'escape' format used in PostgreSQL < 9.0. */
  let bytea_of_string_escape = str => {
    let len = String.length(str);
    let buf = Buffer.create(len);
    let i = ref(0);
    while (i^ < len) {
      let c = str.[i^];
      if (c == '\\') {
        incr(i);
        if (i^ < len && str.[i^] == '\\') {
          Buffer.add_char(buf, '\\');
          incr(i);
        } else if (i^
                   + 2 < len
                   && is_first_oct_digit(str.[i^])
                   && is_oct_digit(str.[i^ + 1])
                   && is_oct_digit(str.[i^ + 2])) {
          let byte = oct_val(str.[i^]);
          incr(i);
          let byte = byte lsl 3 + oct_val(str.[i^]);
          incr(i);
          let byte = byte lsl 3 + oct_val(str.[i^]);
          incr(i);
          Buffer.add_char(buf, Char.chr(byte));
        };
      } else {
        incr(i);
        Buffer.add_char(buf, c);
      };
    };
    Buffer.contents(buf);
  };

  /* PostgreSQL 9.0 introduced the new 'hex' format for binary data.
        We must therefore check whether the data begins with a magic sequence
        that identifies this new format and if so call the appropriate parser;
        if it doesn't, then we invoke the parser for the old 'escape' format.
     */
  let bytea_of_string = str =>
    if (String.starts_with(str, "\\x")) {
      bytea_of_string_hex(str);
    } else {
      bytea_of_string_escape(str);
    };

  let bind = (>>=);
  let return = Thread.return;
};