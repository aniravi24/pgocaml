/* PG'OCaml is a set of OCaml bindings for the PostgreSQL database.
 *
 * PG'OCaml - type safe interface to PostgreSQL.
 * Copyright (C) 2005-2009 Richard Jones and other authors.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this library; see the file COPYING.  If not, write to
 * the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 * Boston, MA 02111-1307, USA.
 */

/**	Type-safe access to PostgreSQL databases. */;

open CalendarLib;

module type THREAD = {
  type t('a);
  let return: 'a => t('a);
  let (>>=): (t('a), 'a => t('b)) => t('b);
  let fail: exn => t('a);
  let catch: (unit => t('a), exn => t('a)) => t('a);

  type in_channel;
  type out_channel;
  let open_connection: Unix.sockaddr => t((in_channel, out_channel));
  let output_char: (out_channel, char) => t(unit);
  let output_binary_int: (out_channel, int) => t(unit);
  let output_string: (out_channel, string) => t(unit);
  let flush: out_channel => t(unit);
  let input_char: in_channel => t(char);
  let input_binary_int: in_channel => t(int);
  let really_input: (in_channel, Bytes.t, int, int) => t(unit);
  let close_in: in_channel => t(unit);
};

module type PGOCAML_GENERIC = {
  /** Database handle. */

  type t('a);

  type monad('a);

  type isolation = [
    | `Serializable
    | `Repeatable_read
    | `Read_committed
    | `Read_uncommitted
  ];

  type access = [ | `Read_write | `Read_only];

  /** For library errors. */

  exception Error(string);

  /** For errors generated by the PostgreSQL database back-end.  The
    first argument is a printable error message.  The second argument
    is the complete set of error fields returned from the back-end.

    See
    [http://www.postgresql.org/docs/8.1/static/protocol-error-fields.html] */

  exception PostgreSQL_Error(string, list((char, string)));

  /** {6 Connection management} */;

  type connection_desc = {
    user: string,
    port: int,
    password: string,
    host: [ | `Hostname(string) | `Unix_domain_socket_dir(string)],
    database: string,
  };

  /** Produce the actual, concrete connection parameters based on the values and
  * availability of the various configuration variables.
  */

  let describe_connection:
    (
      ~host: string=?,
      ~port: int=?,
      ~user: string=?,
      ~password: string=?,
      ~database: string=?,
      ~unix_domain_socket_dir: string=?,
      unit
    ) =>
    connection_desc;

  /** Produce a human-readable textual representation of a concrete connection
  * descriptor (the password is NOT included in the output of this function)
  * for logging and error reporting purposes.
  */

  let connection_desc_to_string: connection_desc => string;

  /** Connect to the database.

    The normal [$PGDATABASE], etc. environment variables are available. */

  let connect:
    (
      ~host: string=?,
      ~port: int=?,
      ~user: string=?,
      ~password: string=?,
      ~database: string=?,
      ~unix_domain_socket_dir: string=?,
      ~desc: connection_desc=?,
      unit
    ) =>
    monad(t('a));

  /** Close the database handle.

    You must call this after you have finished with the handle, or else
    you will get leaked file descriptors. */

  let close: t('a) => monad(unit);

  /** Ping the database.

    If the database is not available, some sort of exception will be
    thrown. */

  let ping: t('a) => monad(unit);

  /** This function is a wrapper of [ping] that returns a boolean
    instead of raising an exception. */

  let alive: t('a) => monad(bool);

  /** {6 Transactions} */;

  /** Start a transaction. */

  let begin_work:
    (
      ~isolation: isolation=?,
      ~access: access=?,
      ~deferrable: bool=?,
      t('a)
    ) =>
    monad(unit);

  /** Perform a COMMIT operation on the database. */

  let commit: t('a) => monad(unit);

  /** Perform a ROLLBACK operation on the database. */

  let rollback: t('a) => monad(unit);

  /** [transact db ?isolation ?access ?deferrable f] wraps your function
    [f] inside a transactional block.  First it calls [begin_work] with
    [isolation], [access] and [deferrable], then calls [f] and do
    [rollback] if [f] raises an exception, [commit] otherwise. */

  let transact:
    (
      t('a),
      ~isolation: isolation=?,
      ~access: access=?,
      ~deferrable: bool=?,
      t('a) => monad('b)
    ) =>
    monad('b);

  /** {6 Serial column} */;

  /** This is a shorthand for [SELECT CURRVAL(serial)].

    For a table called [table] with serial column [id] you would typically
    call this as [serial dbh "table_id_seq"] after the previous INSERT
    operation to get the serial number of the inserted row. */

  let serial: (t('a), string) => monad(int64);

  /** As {!serial} but assumes that the column is a SERIAL or SERIAL4
    type. */

  let serial4: (t('a), string) => monad(int32);

  /** Same as {!serial}. */

  let serial8: (t('a), string) => monad(int64);

  /** {6 Miscellaneous} */;

  /** Maximum message length accepted from the back-end.

    The default is [Sys.max_string_length], which means that we will try
    to read as much data from the back-end as we can, and this may
    cause us to run out of memory (particularly on 64 bit machines),
    causing a possible denial of service.

    You may want to set this to a smaller size to avoid this happening. */

  let max_message_length: ref(int);

  /** Verbosity.

    0 means don't print anything.
    1 means print short error messages as returned from the back-end.
    2 means print all messages as returned from the back-end.

    Messages are printed on [stderr].
    Default verbosity level is 1. */

  let verbose: ref(int);

  /** Attach some private data to the database handle.

    NB. The pa_pgsql camlp4 extension uses this for its own purposes,
    which means that in most programs you will not be able to attach
    private data to the database handle. */

  let set_private_data: (t('a), 'a) => unit;

  /** Retrieve some private data previously attached to the database
    handle. If no data has been attached, raises [Not_found].

    NB. The pa_pgsql camlp4 extension uses this for its own purposes,
    which means that in most programs you will not be able to attach
    private data to the database handle.
*/

  let private_data: t('a) => 'a;

  /** Retrieve the unique identifier for this connection. */

  let uuid: t('a) => string;

  /** When using pa_pgsql, database handles have type
    [PGOCaml.pa_pg_data PGOCaml.t] */

  type pa_pg_data = Hashtbl.t(string, bool);

  /** {6 Low level query interface - DO NOT USE DIRECTLY} */;

  [@deriving show]
  type oid = int32;

  type param = option(string); /* None is NULL. */
  type result = option(string); /* None is NULL. */
  type row = list(result); /* One row is a list of fields. */

  /** [prepare conn ~query ?name ?types ()] prepares the statement
    [query] and optionally names it [name] and sets the parameter types
    to [types].

    If no name is given, then the "unnamed" statement is overwritten.
    If no types are given, then the PostgreSQL engine infers types.
    Synchronously checks for errors. */

  let prepare:
    (t('a), ~query: string, ~name: string=?, ~types: list(oid)=?, unit) =>
    monad(unit);

  let execute_rev:
    (
      t('a),
      ~name: string=?,
      ~portal: string=?,
      ~params: list(param),
      unit
    ) =>
    monad(list(row));
  /** [execute conn ?name ~params ()] executes the named or unnamed
    statement [name], with the given parameters [params], returning the
    result rows (if any).

    There are several steps involved at the protocol layer:

    (1) a "portal" is created from the statement, binding the
    parameters in the statement (Bind).

    (2) the portal is executed (Execute).

    (3) we synchronise the connection (Sync).

    The optional [?portal] parameter may be used to name the portal
    created in step (1) above (otherwise the unnamed portal is used).
    This is only important if you want to call {!describe_portal} to
    find out the result types. */

  let execute:
    (
      t('a),
      ~name: string=?,
      ~portal: string=?,
      ~params: list(param),
      unit
    ) =>
    monad(list(row));

  let cursor:
    (
      t('a),
      ~name: string=?,
      ~portal: string=?,
      ~params: list(param),
      row => monad(unit)
    ) =>
    monad(unit);

  /** [close_statement conn ?name ()] closes a prepared statement and
    frees up any resources. */

  let close_statement: (t('a), ~name: string=?, unit) => monad(unit);

  /** [close_portal conn ?portal ()] closes a portal and frees up any
    resources. */

  let close_portal: (t('a), ~portal: string=?, unit) => monad(unit);

  /** [inject conn ?name query] executes the statement [query] and
    optionally names it [name] and gives the result. */

  let inject: (t('a), ~name: string=?, string) => monad(list(row));

  /** [alter conn ?name query] executes the statement [query] and
    optionally names it [name]. Same as inject but ignoring the
    result. */

  let alter: (t('a), ~name: string=?, string) => monad(unit);

  [@deriving show]
  type result_description = {
    /** Field name. */
    name: string,
    /** OID of table. */
    table: option(oid),
    /** Column number of field in table. */
    column: option(int),
    /** The type of the field. */
    field_type: oid,
    /** Length of the field. */
    length: int,
    /** Type modifier. */
    modifier: int32,
  };
  [@deriving show]
  type row_description = list(result_description);

  type params_description = list(param_description)
  and param_description = {
    /** The type of the parameter. */
    param_type: oid,
  };

  /** [describe_statement conn ?name ()] describes the named or unnamed
    statement's parameter types and result types. */

  let describe_statement:
    (t('a), ~name: string=?, unit) =>
    monad((params_description, option(row_description)));

  /** [describe_portal conn ?portal ()] describes the named or unnamed
    portal's result types. */

  let describe_portal:
    (t('a), ~portal: string=?, unit) => monad(option(row_description));

  /** {6 Low level type conversion functions - DO NOT USE DIRECTLY} */;

  /** Returns the OCaml equivalent type name to the PostgreSQL type
    [oid].

    For instance, [name_of_type (Int32.of_int 23)] returns ["int32"]
    because the OID for PostgreSQL's internal [int4] type is [23].

    As another example, [name_of_type (Int32.of_int 25)] returns
    ["string"]. */

  let name_of_type: oid => string;

  type inet = (Unix.inet_addr, int);
  type timestamptz = (Calendar.t, Time_Zone.t);
  type int16 = int;
  type bytea = string; /* XXX */
  type point = (float, float);
  type hstore = list((string, option(string)));
  type numeric = string;
  type uuid = string;
  type jsonb = string;

  type bool_array = list(option(bool));
  type int32_array = list(option(int32));
  type int64_array = list(option(int64));
  type string_array = list(option(string));
  type float_array = list(option(float));
  type timestamp_array = list(option(Calendar.t));

  /** The following conversion functions are used by pa_pgsql to convert
    values in and out of the database. */;

  let string_of_oid: oid => string;
  let string_of_bool: bool => string;
  let string_of_int: int => string;
  let string_of_int16: int16 => string;
  let string_of_int32: int32 => string;
  let string_of_int64: int64 => string;
  let string_of_float: float => string;
  let string_of_point: point => string;
  let string_of_hstore: hstore => string;
  let string_of_numeric: numeric => string;
  let string_of_uuid: uuid => string;
  let string_of_jsonb: jsonb => string;
  let string_of_inet: inet => string;
  let string_of_timestamp: Calendar.t => string;
  let string_of_timestamptz: timestamptz => string;
  let string_of_date: Date.t => string;
  let string_of_time: Time.t => string;
  let string_of_interval: Calendar.Period.t => string;
  let string_of_bytea: bytea => string;
  let string_of_string: string => string;
  let string_of_unit: unit => string;

  let string_of_bool_array: bool_array => string;
  let string_of_int32_array: int32_array => string;
  let string_of_int64_array: int64_array => string;
  let string_of_string_array: string_array => string;
  let string_of_bytea_array: string_array => string;
  let string_of_float_array: float_array => string;
  let string_of_timestamp_array: timestamp_array => string;
  let string_of_arbitrary_array: ('a => string, list(option('a))) => string;

  let comment_src_loc: unit => bool;

  let find_custom_typconvs:
    (
      ~typnam: string=?,
      ~lookin: string=?,
      ~colnam: string=?,
      ~argnam: string=?,
      unit
    ) =>
    Rresult.result(option((string, string)), string);

  let oid_of_string: string => oid;
  let bool_of_string: string => bool;
  let int_of_string: string => int;
  let int16_of_string: string => int16;
  let int32_of_string: string => int32;
  let int64_of_string: string => int64;
  let float_of_string: string => float;
  let point_of_string: string => point;
  let hstore_of_string: string => hstore;
  let numeric_of_string: string => numeric;
  let uuid_of_string: string => uuid;
  let jsonb_of_string: string => jsonb;
  let inet_of_string: string => inet;
  let timestamp_of_string: string => Calendar.t;
  let timestamptz_of_string: string => timestamptz;
  let date_of_string: string => Date.t;
  let time_of_string: string => Time.t;
  let interval_of_string: string => Calendar.Period.t;
  let bytea_of_string: string => bytea;
  let unit_of_string: string => unit;

  let bool_array_of_string: string => bool_array;
  let int32_array_of_string: string => int32_array;
  let int64_array_of_string: string => int64_array;
  let string_array_of_string: string => string_array;
  let float_array_of_string: string => float_array;
  let timestamp_array_of_string: string => timestamp_array;
  let arbitrary_array_of_string: (string => 'a, string) => list(option('a));

  let bind: (monad('a), 'a => monad('b)) => monad('b);
  let return: 'a => monad('a);
};

module Make:
  (Thread: THREAD) => PGOCAML_GENERIC with type monad('a) = Thread.t('a);
